# Automated Cross-Platform Packaging

## Introduction

This guide provides a step-by-step process for configuring a GitHub Actions
workflow to automatically build and package the `comenq` client and `comenqd`
daemon for Linux (Fedora, Ubuntu). macOS packaging remains on hold, so the
workflow focuses on Linux targets only. The current implementation replaces the
earlier GoReleaser flow with composite actions hosted in
`leynos/shared-actions`. These actions orchestrate the Rust build, stage the
man pages generated by the workspace build scripts, and delegate all packaging
to the shared `linux-packages` helper. The helper emits `.rpm` and `.deb`
artefacts for each binary without invoking `nfpm` directly in the workflow.

The workflow matrix iterates over both binaries (`comenq` and `comenqd`) and
the supported Linux targets (`x86_64-unknown-linux-gnu` and
`aarch64-unknown-linux-gnu`). For each combination the `rust-build-release`
action compiles the workspace with the correct target toolchain and stages the
matching man page. The downstream `linux-packages` composite action, executed
by `rust-build-release`, generates the `nfpm` manifest and packages the staged
artefacts in one pass. This keeps the workflow lean—only the shared action ever
executes `nfpm`—and ensures the generated `.deb` and `.rpm` files are ready to
upload. Finally, `softprops/action-gh-release` publishes the generated packages
to a draft GitHub Release, preserving the previous workflow's release review
gate.

The remainder of this document captures the original GoReleaser-oriented plan
for historical context. The high-level packaging requirements remain relevant,
but the automation now lives entirely in `.github/workflows/release.yml` via
the shared composite actions described above.

### Part 1: Packaging for Fedora and Ubuntu with systemd

The first stage is to package `comenqd` as a `systemd` service for modern Linux
distributions.

#### Step 1: Create the `systemd` Unit File

First, create a `systemd` unit file that will manage the `comenqd` daemon. This
file defines how the service should be started, stopped, and managed by
`systemd`. It includes security hardening measures by specifying a dedicated
user and group and restricting filesystem access.

Create the following file in your repository. A good location is
`packaging/linux/comenqd.service`:

```systemd,ini
[Unit]
Description=Comenq Daemon
Documentation=https://github.com/leynos/comenq
After=network.target

[Service]
# Run the service as the 'comenq' user and group
User=comenq
Group=comenq

# The command to start the daemon
# Assumes the binary is installed to /usr/bin/comenqd
# The configuration file is expected at /etc/comenqd/config.toml
ExecStart=/usr/bin/comenqd --config /etc/comenqd/config.toml

# Security Hardening
# Disallow any privileges
CapabilityBoundingSet=
# Deny writing to the entire filesystem
ProtectSystem=strict
# Mount /home, /root, and /run/user as read-only
ProtectHome=read-only
# Use a private /tmp directory
PrivateTmp=true
# Disallow acquiring new privileges
NoNewPrivileges=true
# Restrict access to device nodes
PrivateDevices=true
# Make the kernel log, control, and audit files inaccessible
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectControlGroups=true

# Restart the service if it fails
Restart=on-failure
RestartSec=5s

[Install]
WantedBy=multi-user.target
```

**Note:** This unit file assumes a configuration file at
`/etc/comenqd/config.toml`. A default configuration file must ship with the
package.

#### Step 2: Create a Default Configuration File

Create a default `config.toml` file to be included in the packages. Place it at
`packaging/config/comenqd.toml`.

```toml
# Default configuration for comenqd
# github_token = ""
# log_level = "info"
# socket_path = "/run/comenq/comenq.sock"
# queue_path = "/var/lib/comenq/queue"
# cooldown_period_seconds = 960
```

#### Step 3: Create Installation Scripts

The `systemd` unit file requires a dedicated user. These scripts will create
the `comenq` user and group upon installation.

**packaging/linux/[preinstall.sh](http://preinstall.sh)**

```bash
#!/bin/bash
set -euo pipefail
if ! getent group comenq >/dev/null; then
    groupadd --system comenq || { echo "failed to add group" >&2; exit 1; }
fi
if ! getent passwd comenq >/dev/null; then
    useradd --system --gid comenq --home-dir /var/lib/comenq \
        --create-home --shell /sbin/nologin comenq \
        || { echo "failed to add user" >&2; exit 1; }
fi
chown comenq:comenq /var/lib/comenq
chmod 750 /var/lib/comenq
```

**packaging/linux/[postinstall.sh](http://postinstall.sh)**

```bash
#!/bin/bash
set -euo pipefail
# Reload systemd to recognize the new service, then enable and start it.
systemctl daemon-reload
systemctl enable comenqd.service
systemctl start comenqd.service
```

**packaging/linux/[preremove.sh](http://preremove.sh)**

```bash
#!/bin/bash
set -euo pipefail
# Stop and disable the service before removal.
if systemctl is-active --quiet comenqd.service; then
    systemctl stop comenqd.service
fi
if systemctl is-enabled --quiet comenqd.service; then
    systemctl disable comenqd.service
fi
```

Make these scripts executable: `chmod +x packaging/linux/*.sh`.

#### Step 4: Update the GitHub Actions Workflow

Finally, modify your existing `.github/workflows/release.yml` to use
GoReleaser. This workflow will trigger when you push a new tag (e.g., `v1.2.3`).

#### `.github/workflows/release.yml`

```yaml
name: Release

on:
  push:
    tags:
      - 'v[0-9]*.[0-9]*.[0-9]*'

jobs:
  goreleaser:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
          targets: x86_64-unknown-linux-gnu, aarch64-unknown-linux-gnu
          cache: cargo

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Run GoReleaser
        uses: goreleaser/goreleaser-action@v5
        with:
          distribution: goreleaser
          version: v1.24.0
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

### Part 2: Extending to macOS with `launchd` and Homebrew

Now we will extend the configuration to support macOS by creating a `launchd`
service and a Homebrew Tap.

#### Step 1: Create the `launchd` Plist File

On macOS, services are managed by `launchd`. The equivalent of a `systemd` unit
file is a `.plist` file.

Create `packaging/darwin/comenqd.plist`:

```plist,xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.github.leynos.comenqd</string>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/local/bin/comenqd</string>
        <string>--config</string>
        <string>/usr/local/etc/comenqd/config.toml</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
    <key>StandardOutPath</key>
    <string>/usr/local/var/log/comenq/comenqd.log</string>
    <key>StandardErrorPath</key>
    <string>/usr/local/var/log/comenq/comenqd.err</string>
</dict>
</plist>

```

#### Step 2: Update `.goreleaser.yaml` for Homebrew

Now, add the `brews` section to your `.goreleaser.yaml` to generate a Homebrew
formula. This will create a formula in a separate repository (your "tap").

First, create a new, public GitHub repository named `homebrew-tap`.

Then, add the following section to `.goreleaser.yaml`:

```yaml
# .goreleaser.yaml (additions)

brews:
  - name: comenq
    # The GitHub repository for your Homebrew tap.
    tap:
      owner: leynos
      name: homebrew-tap
      # A token with write access to the tap repository.
      # You'll need to create a Personal Access Token (PAT) and add it
      # as a secret named HOMEBREW_TAP_TOKEN to your comenq repo.
      token: "{{ .Env.HOMEBREW_TAP_TOKEN }}"

    # The commit author
    commit_author:
      name: goreleaserbot
      email: bot@goreleaser.com

    # The homepage for the formula
    homepage: "https://github.com/leynos/comenq"
    description: "Client and Daemon for the Comenq notification system."
    license: "MIT"

    # Specify which builds to include. We will package both binaries
    # in the same formula.
    builds:
      - comenq
      - comenqd

    # Additional files to include in the formula.
    # We include the plist file for the service.
    # GoReleaser will automatically generate the service block.
    extra_files:
      - glob: ./packaging/darwin/comenqd.plist
        # This ensures the plist is renamed to match the formula name
        name_template: "{{ .ProjectName }}.plist"

    # The service block for `comenqd`
    service: |
      run [opt_bin/"comenqd", "--config", etc/"comenqd/config.toml"]
      keep_alive true
      log_path var/"log/comenq/comenqd.log"
      error_log_path var/"log/comenq/comenqd.err"

    # Install instructions for the user
    install: |
      bin.install "comenq"
      bin.install "comenqd"
      (etc/"comenqd").mkpath
      (var/"log/comenq").mkpath
```

#### Step 3: Add the macOS Configuration File

The Homebrew formula also installs a default configuration. The file lives at
`packaging/config/comenqd.toml`, so the `install` section must reference this
path to place the configuration in `etc`.

#### Step 4: Final `.goreleaser.yaml`

Here is the complete `.goreleaser.yaml` with both Linux and macOS
configurations:

```yaml
# .goreleaser.yaml
project_name: comenq

plugins:
  - import: github.com/goreleaser/goreleaser-rust@v1.6.0

builds:
  - id: comenq
    binary: comenq
    main: ./crates/comenq
    builder: rust
    targets:
      - x86_64-unknown-linux-gnu
      - aarch64-unknown-linux-gnu
      - x86_64-apple-darwin
      - aarch64-apple-darwin
  - id: comenqd
    binary: comenqd
    main: ./crates/comenqd
    builder: rust
    targets:
      - x86_64-unknown-linux-gnu
      - aarch64-unknown-linux-gnu
      - x86_64-apple-darwin
      - aarch64-apple-darwin

archives:
  - id: default
    name_template: "{{ .ProjectName }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}"
    format: tar.gz
    files:
      - LICENSE
      - README.md
      - packaging/config/comenqd.toml

nfpms:
  - id: comenq-packages
    package_name: comenq
    vendor: "Your Name"
    homepage: "https://github.com/leynos/comenq"
    maintainer: "Your Name <your.email@example.com>"
    description: "Client for the Comenq notification system."
    license: MIT
    formats: [deb, rpm]
    builds: [comenq]

  - id: comenqd-packages
    package_name: comenqd
    vendor: "Your Name"
    homepage: "https://github.com/leynos/comenq"
    maintainer: "Your Name <your.email@example.com>"
    description: "Daemon for the Comenq notification system."
    license: MIT
    formats: [deb, rpm]
    builds: [comenqd]
    contents:
      - src: packaging/linux/comenqd.service
        dst: /lib/systemd/system/comenqd.service
      - src: packaging/config/comenqd.toml
        dst: /etc/comenqd/config.toml
        type: config
    scripts:
      preinstall: "packaging/linux/preinstall.sh"
      postinstall: "packaging/linux/postinstall.sh"
      preremove: "packaging/linux/preremove.sh"

brews:
  - name: comenq
    tap:
      owner: leynos
      name: homebrew-tap
      token: "{{ .Env.HOMEBREW_TAP_TOKEN }}"
    commit_author:
      name: goreleaserbot
      email: bot@goreleaser.com
    homepage: "https://github.com/leynos/comenq"
    description: "Client and Daemon for the Comenq notification system."
    license: "MIT"
    builds: [comenq, comenqd]
    service: |
      run [opt_bin/"comenqd", "--config", etc/"comenqd/config.toml"]
      keep_alive true
      log_path var/"log/comenq/comenqd.log"
      error_log_path var/"log/comenq/comenqd.err"
    install: |
      bin.install "comenq"
      bin.install "comenqd"
      (etc/"comenqd").mkpath
      etc.install "packaging/config/comenqd.toml" => "comenqd/config.toml"
      (var/"log/comenq").mkpath

release:
  github:
    owner: leynos
    name: comenq
  draft: true

changelog:
  sort: asc
  filters:
    exclude:
      - '^docs:'
      - '^test:'
      - '^chore:'
      - '^style:'
      - 'Merge pull request'
      - 'Merge branch'
```

### Final Steps and Usage

1. **Create a Personal Access Token (PAT)** for the Homebrew tap. Go to your
   GitHub Developer settings, create a new token with the `public_repo` scope,
   and add it as a repository secret named `HOMEBREW_TAP_TOKEN` in your
   `comenq` repository.

2. **Commit and Push:** Add all the new files (`.goreleaser.yaml`, service
   files, install scripts) to your repository.

3. **Tag a Release:** To trigger the workflow, create and push a new tag:

   ```bash
   git tag -a v0.1.0 -m "Release v0.1.0"
   git push origin v0.1.0
   ```

The GitHub Actions workflow will now run, build your binaries, create the
`.deb` and `.rpm` packages, upload them to a new GitHub Release, and finally,
publish the Homebrew formula to your `homebrew-tap` repository. Your users can
then install `comenq` using their native package managers.
